The finish module is an important module to reason since it makes sure that an entity is ready to go live before it is made live.  It checks the entity to make sure none of its fields have errors, checks to see if there are any required relationships that are empty, and it's on the second level of editing and it's creating a new entity, it creates a relationship between the current entity and the first level entity.  

First, the finish module checks all entity fields to make sure they're correct.  We have to use a little trick here to make sure this is done properly.  Normally, we'd only create a Disco object to create a form, but in this case, we create one just to do the error checks.  We have to cheat a little bit here since we are technically calling a "private" function to do this.  Creating the disco item is done similarly to the way it's done in the editor module.  We include the default content manager and then if the type has a custom content manager set up, we include that one as well.  We then instantiate the new content manager and call the prep_for_run() and init() functions.  Here we don't use the run function, we rather call just the functions which are necessary for check errors.  We call on_every_time(), pre_error_check_actions(), and then finally _run_all_error_checks().  Then, if the form has errors, we send the user back to the editor page with the submitted variable set to true (so the errors show up on that page).  

Next, we check to see if there are required relationships that are not set.  First, get_required_relationships() is called which just builds up a large query and puts the values into the class variable req_rels.  This query makes sure that all relationships that are being selected are 1) Relationships where the current type is on the left side; 2) The relationship is required; 3) custom_associator is empty (if this is set it usually means that this relationship is handled in the content_manager); and 4) the current site has access to the type on the right side of the relationship.  The function check_required_relationships() is then called.  This function simply loops through all the required relationships and checks to make sure there is at least one association of that type.  If there is not, it redirects you to that association page with an error message saying that the user needs to select something.  

Finally, if we are on the second level of editing, we create that relationship.  At this point, we are ready to send the user back to where they came from.  If the user is on the first level, they're sent back to the lister page for the current type.  If they're on the second level, they're sent back to where they came from in the first level.  

